# Tech test

## About 

This repository is an example repository containing both an elixir backend and a typescript react application in the front end. It is designed to be a small, but realistic web application for use in pair programming technical test exercises. 

As part of the exercises, the interviewee will go through, learning a small amount about the repository followed by implementing a small feature across back and front end. 

## Getting started

Install dependencies

```
make setup
```

Run app for development (starts dev server on http://localhost:5173/)

```
make
```

Has HMR for front end and live updates for the backend

## Development

### Recommended VSCode Extentions

-   [Credo](https://marketplace.visualstudio.com/items?itemName=pantajoe.vscode-elixir-credo) - Elixir Linting / Static Analysis
-   [Prettier](https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode) - TypeScript formatting
-   [vscode-styled-components](https://marketplace.visualstudio.com/items?itemName=styled-components.vscode-styled-components) - Syntax highlighting and suggestions for styled components

### Developing React

**Routing**

To add a new page/route on the front end you can create a new file in the `app/src/routes` directory, the folder that you put this file in should follow roughly follow the path structure e.g. if the path is `/account/:account_id/edit` it is probably reasonable to have the page at `routes/account/edit.tsx` where the component is something clear like `export default function EditAccountPage`.
The page is the added to the router as an object in the routes list as:

```
{
   path: "/account/:account_id/edit",
   element: <EditAccountPage />,
 }
```

More details can be found in the [React Router Docs](https://reactrouter.com/en/main/routers/create-browser-router)

**Communicating with the backend**
For communicating with the backend there are some tools exported from `app/src/api` which are wrappers around `useQuery` and `useMutation` that provide intellisense for available endpoints and request and response types based on the route. These are generated from the open api specs created in the backend which are generated by `make api-specs`.

For any query or mutation it is recommended that you create a custom hook in the relevant file/folder in `app/src/api` that uses our query or mutation utility. e.g. if we have the endpoint `/api/todo` that fetches a list of todos we could create the file `app/src/api/todo.tsx` which looks like this

```
// Use our useQuery not the one from @tanstack/react-query
import { useQuery } from '.'

export const useTodos = () => useQuery('/api/todo')
```

By doing this where we use `useTodos` like so `const { data } = useTodos()` we should have full knowledge of what types to expect.

For queries and mutations that have parameters we use the literal path e.g. `/api/todo/{id}` and pass the relevant parameters as the 2nd argument `useQuery('/api/todo/{id}', {id: 123})` which will format the path with the correct parameters

With react-query the pattern for mutations that affect a piece of state that you have i.e. checking off a todo in a list of todos is to invalidate the query which causes it to refetch, we can do that with the `onSuccess` callback and `queryClient.invalidateQueries` function, that would look like this

```
export const useToggleTodo = () => {
  const queryClient = useQueryClient();

  return useMutation("/api/todo/toggle", {
    onSuccess: () => queryClient.invalidateQueries(["/api/todo"]),
  });
};
```

One other very nice optimisation is using optimistic updates when we know what the expected outcome will be, a good example for this is the mutation above since all it will do is toggle a todo to completed. We can make a few updates to make this change happen instantly and then it will still fetch the updated list from the backend.

```
export const useToggleTodo = () => {
  const queryClient = useQueryClient();

  return useMutation("/api/todo/toggle", {
    onSuccess: () => queryClient.invalidateQueries(["/api/todo"]),
    onMutate: async ({ id }) => {
      await queryClient.cancelQueries(["/api/todo"]);
      const previousTodos = queryClient.getQueryData(["/api/todo"]);
      queryClient.setQueryData<QueryResponse<"/api/todo">>(
        ["/api/todo"],
        (old) => {
          if (!old?.data) return old;

          return {
            data: old.data.map((oldTodo) => {
              if (oldTodo.id !== id) return oldTodo;

              return { ...oldTodo, completed: !oldTodo.completed };
            }),
          };
        }
      );

      return { previousTodos };
    },
    onError: (err, newTodo, context: any) => {
      queryClient.setQueryData(["/api/todos"], context.previousTodos);
    },
  });
};
```

Read more about [Query Invalidation](https://tanstack.com/query/v4/docs/react/guides/query-invalidation) and [Optimistic Updates](https://tanstack.com/query/v4/docs/react/guides/optimistic-updates)
